func name arg1 : num , arg2 : num {
    num result = arg1 + arg2 ;

    return result ;
}

### function to showcase quicks ###
func bruhShowcase myArgument1 : num , myArgument2 : num { # return myArgument1 times myArgument2. myArgument1 and myArgument2 are RAM variables
    quick myQuickVariable = myArgument1 ;
    quick myOtherQuickVariable = myArgument2 ;
    # quick variables are stored in regs but are assigned by the programmer, to optimize code

    quick result = myQuickVariable * myOtherQuickVariable ; # makes it just 1 line in URCL because of quicks being in registers

    return result ;
}

### function to showcase freeing of stuff
func bruhShowcase2 arg1 : num , arg2 : num {
    quick quick1 = arg1 ;
    quick quick2 = arg2 ;

    quick quick3 = quick1 * quick2 ;
    free quick1 ;

    quick quick4 = quick2 * 5 ;
    free quick2 ;

    quick quick5 = quick3 + quick4 ;
    return quick5 ;
    # all variables get automatically freed up when ending a function
}

### objects?
obj myCool inheritedClass? {
    num x = 4 ;
    num y = 42 ;
    num zx = 23 ;

    func myCool sixtyNine : int { # dumb constructor
        quick sixtynineplusone = sixtyNine + 1

        x = sixtynineplusone
        y = sixtynineplusone - 1
    }
}

### functions to showcase objects & variable types and cool stuff
func random scoolar : int {
    int n = 0 ;
    int u = 0 ;

    for $0 < scoolar { # a for loop! ($0 can be replaced with whatever variable name)
        n + 1 ;
        u + $0 ;
    }

    return u + n ;
}

func coolfunc coolarg1 : byte , coolarg2 : byte { # showcasing argument types
    myCool objectfriend = construct myCool 69 ; # showcasing how to construct a class

    int lol = objectfriend . zx ; # accessing a class
    long lolol = 123456789123555 ;
    short lololol = 65535 ;
    lololol + 1 ; # lololol = 0

    lolol = objectfriend . x ; # accessing a class

    random 60 ; # calling a function
}